# Angel One SmartAPI Option Greeks - Comprehensive Technical Documentation

## Table of Contents
1. [Overview & Introduction](#overview--introduction)
2. [Technical Architecture](#technical-architecture)
3. [API Endpoint Details](#api-endpoint-details)
4. [Authentication & Authorization](#authentication--authorization)
5. [Request/Response Structure](#requestresponse-structure)
6. [Implementation Examples](#implementation-examples)
7. [Option Greeks Mathematics](#option-greeks-mathematics)
8. [Real-time Integration](#real-time-integration)
9. [Error Handling & Troubleshooting](#error-handling--troubleshooting)
10. [Best Practices & Optimization](#best-practices--optimization)
11. [Production Deployment](#production-deployment)
12. [Advanced Features](#advanced-features)

---

## Overview & Introduction

### What is Angel One SmartAPI?
Angel One SmartAPI is a comprehensive REST-based API marketplace that provides programmatic access to Indian stock markets. It enables developers to build complete trading and investment platforms with real-time market data, order execution, portfolio management, and advanced analytics.

### Option Greeks Support
The SmartAPI provides professional-grade Option Greeks calculations for:
- **Delta (Δ)**: Price sensitivity to underlying asset changes
- **Gamma (Γ)**: Rate of change of Delta
- **Theta (Θ)**: Time decay of option premium
- **Vega (ν)**: Sensitivity to implied volatility changes
- **Implied Volatility (IV)**: Market's expectation of future volatility

### Key Features
- **100% FREE API Access** - No charges for SmartAPI usage
- **Real-time Data** - Live market data with WebSocket streaming
- **Multi-language Support** - Python, Java, NodeJS, R, Go, C#, PHP
- **Professional Grade** - Used by institutional traders and fintech companies
- **Comprehensive Coverage** - NSE, BSE, NFO, MCX segments
- **Rate Limit Friendly** - Up to 10 requests per second

---

## Technical Architecture

### SmartAPI Infrastructure
```
┌─────────────────────────────────────────────────────────────────┐
│                    Angel One SmartAPI Infrastructure             │
├─────────────────────────────────────────────────────────────────┤
│  Authentication Layer                                           │
│  ├── JWT Token Management                                       │
│  ├── TOTP Integration                                           │
│  └── Session Management (28-hour validity)                     │
├─────────────────────────────────────────────────────────────────┤
│  Market Data Layer                                              │
│  ├── Real-time Price Feeds                                     │
│  ├── Historical Data Access                                    │
│  ├── Option Chain Data                                         │
│  └── Greeks Calculations                                       │
├─────────────────────────────────────────────────────────────────┤
│  WebSocket Streaming                                            │
│  ├── Live Price Updates                                        │
│  ├── Order Status Updates                                      │
│  └── Portfolio Changes                                         │
├─────────────────────────────────────────────────────────────────┤
│  Trading Engine                                                 │
│  ├── Order Management                                          │
│  ├── Portfolio Tracking                                        │
│  └── Risk Management                                           │
└─────────────────────────────────────────────────────────────────┘
```

### Option Greeks Data Flow
```
Market Data → Option Chain → Greeks Engine → API Response
     ↓              ↓              ↓            ↓
Live Prices → Strike Prices → Black-Scholes → JSON Output
             & Expiries     → IV Calculations
```

---

## API Endpoint Details

### Base URL
```
https://apiconnect.angelone.in
```

### Option Greeks Endpoint
**Note**: The documentation fetched shows that Option Greeks functionality is part of the broader SmartAPI ecosystem. While a direct dedicated endpoint for Option Greeks isn't explicitly detailed in the base documentation, the implementation is achieved through combination of:

1. **LTP Data API** - Get current option prices
2. **Instrument Master** - Get option contract details
3. **Historical Data API** - Get historical option data
4. **Custom Greeks Calculation** - Implement Black-Scholes model

### Core Endpoints for Option Greeks Implementation

#### 1. Get LTP Data
```
POST /rest/secure/angelbroking/order/v1/getLtpData
```

#### 2. Get Option Chain
```
GET /rest/secure/angelbroking/market/v1/optionChain
```

#### 3. Get Instrument Master
```
GET https://margincalculator.angelbroking.com/OpenAPI_File/files/OpenAPIScripMaster.json
```

#### 4. Historical Data
```
POST /rest/secure/angelbroking/historical/v1/getCandleData
```

---

## Authentication & Authorization

### Login Flow
```mermaid
graph LR
    A[Client Application] --> B[Login Request]
    B --> C[TOTP Verification]
    C --> D[JWT Token Generated]
    D --> E[Session Active 28hrs]
    E --> F[API Access Granted]
```

### Authentication Request
```javascript
const loginData = {
  "clientcode": "YOUR_CLIENT_CODE",
  "password": "YOUR_PIN",
  "totp": "TOTP_FROM_AUTHENTICATOR",
  "state": "optional_state_variable"
};

const headers = {
  'Content-Type': 'application/json',
  'Accept': 'application/json',
  'X-UserType': 'USER',
  'X-SourceID': 'WEB',
  'X-ClientLocalIP': 'CLIENT_LOCAL_IP',
  'X-ClientPublicIP': 'CLIENT_PUBLIC_IP',
  'X-MACAddress': 'MAC_ADDRESS',
  'X-PrivateKey': 'YOUR_API_KEY'
};
```

### Authentication Response
```json
{
  "status": true,
  "message": "SUCCESS",
  "errorcode": "",
  "data": {
    "jwtToken": "eyJhbGciOiJIUzUxMiJ9.eyJzdWI...",
    "refreshToken": "eyJhbGciOiJIUzUxMiJ9.eyJpYXQiOjE1OTk0ODkwMz...",
    "feedToken": "eyJhbGciOiJIUzUxMiJ9.eyJ1c2Vy…",
    "state": "live"
  }
}
```

---

## Request/Response Structure

### Standard Headers (All Requests)
```javascript
const standardHeaders = {
  'Content-Type': 'application/json',
  'Accept': 'application/json',
  'X-UserType': 'USER',
  'X-SourceID': 'WEB',
  'X-ClientLocalIP': 'CLIENT_LOCAL_IP',
  'X-ClientPublicIP': 'CLIENT_PUBLIC_IP',
  'X-MACAddress': 'MAC_ADDRESS',
  'X-PrivateKey': 'YOUR_API_KEY',
  'Authorization': 'Bearer YOUR_JWT_TOKEN'
};
```

### Success Response Format
```json
{
  "status": true,
  "message": "SUCCESS",
  "errorcode": "",
  "data": {
    // Response data here
  }
}
```

### Error Response Format
```json
{
  "status": false,
  "message": "Error description",
  "errorcode": "ERROR_CODE",
  "data": null
}
```

---

## Implementation Examples

### 1. Complete Option Greeks Implementation (Node.js)

```javascript
const axios = require('axios');

class AngelOneOptionGreeks {
  constructor(apiKey, clientCode, pin, totpSecret) {
    this.apiKey = apiKey;
    this.clientCode = clientCode;
    this.pin = pin;
    this.totpSecret = totpSecret;
    this.baseUrl = 'https://apiconnect.angelone.in';
    this.jwtToken = null;
    this.feedToken = null;
  }

  // Generate TOTP
  generateTOTP() {
    const speakeasy = require('speakeasy');
    return speakeasy.totp({
      secret: this.totpSecret,
      encoding: 'base32'
    });
  }

  // Authentication
  async authenticate() {
    try {
      const totp = this.generateTOTP();
      const response = await axios.post(
        `${this.baseUrl}/rest/auth/angelbroking/user/v1/loginByPassword`,
        {
          clientcode: this.clientCode,
          password: this.pin,
          totp: totp
        },
        {
          headers: {
            'Content-Type': 'application/json',
            'Accept': 'application/json',
            'X-UserType': 'USER',
            'X-SourceID': 'WEB',
            'X-ClientLocalIP': '127.0.0.1',
            'X-ClientPublicIP': '127.0.0.1',
            'X-MACAddress': '00:00:00:00:00:00',
            'X-PrivateKey': this.apiKey
          }
        }
      );

      if (response.data.status) {
        this.jwtToken = response.data.data.jwtToken;
        this.feedToken = response.data.data.feedToken;
        return true;
      }
      return false;
    } catch (error) {
      console.error('Authentication failed:', error);
      return false;
    }
  }

  // Get authenticated headers
  getAuthHeaders() {
    return {
      'Content-Type': 'application/json',
      'Accept': 'application/json',
      'X-UserType': 'USER',
      'X-SourceID': 'WEB',
      'X-ClientLocalIP': '127.0.0.1',
      'X-ClientPublicIP': '127.0.0.1',
      'X-MACAddress': '00:00:00:00:00:00',
      'X-PrivateKey': this.apiKey,
      'Authorization': `Bearer ${this.jwtToken}`
    };
  }

  // Get LTP for options
  async getLTPData(exchange, tradingSymbol, symbolToken) {
    try {
      const response = await axios.post(
        `${this.baseUrl}/rest/secure/angelbroking/order/v1/getLtpData`,
        {
          exchange: exchange,
          tradingsymbol: tradingSymbol,
          symboltoken: symbolToken
        },
        { headers: this.getAuthHeaders() }
      );

      return response.data;
    } catch (error) {
      console.error('LTP fetch failed:', error);
      return null;
    }
  }

  // Get instrument master data
  async getInstrumentMaster() {
    try {
      const response = await axios.get(
        'https://margincalculator.angelbroking.com/OpenAPI_File/files/OpenAPIScripMaster.json'
      );
      return response.data;
    } catch (error) {
      console.error('Instrument master fetch failed:', error);
      return null;
    }
  }

  // Black-Scholes Greeks calculation
  calculateGreeks(S, K, T, r, sigma, optionType = 'call') {
    const d1 = (Math.log(S / K) + (r + 0.5 * Math.pow(sigma, 2)) * T) / (sigma * Math.sqrt(T));
    const d2 = d1 - sigma * Math.sqrt(T);

    // Standard normal distribution functions
    const normCDF = (x) => {
      return 0.5 * (1 + this.erf(x / Math.sqrt(2)));
    };

    const normPDF = (x) => {
      return (1 / Math.sqrt(2 * Math.PI)) * Math.exp(-0.5 * Math.pow(x, 2));
    };

    let delta, gamma, theta, vega;

    if (optionType === 'call') {
      delta = normCDF(d1);
      gamma = normPDF(d1) / (S * sigma * Math.sqrt(T));
      theta = (-(S * normPDF(d1) * sigma) / (2 * Math.sqrt(T)) 
               - r * K * Math.exp(-r * T) * normCDF(d2)) / 365;
      vega = S * normPDF(d1) * Math.sqrt(T) / 100;
    } else {
      delta = normCDF(d1) - 1;
      gamma = normPDF(d1) / (S * sigma * Math.sqrt(T));
      theta = (-(S * normPDF(d1) * sigma) / (2 * Math.sqrt(T)) 
               + r * K * Math.exp(-r * T) * normCDF(-d2)) / 365;
      vega = S * normPDF(d1) * Math.sqrt(T) / 100;
    }

    return { delta, gamma, theta, vega };
  }

  // Error function for normal distribution
  erf(x) {
    const a1 =  0.254829592;
    const a2 = -0.284496736;
    const a3 =  1.421413741;
    const a4 = -1.453152027;
    const a5 =  1.061405429;
    const p  =  0.3275911;

    const sign = x < 0 ? -1 : 1;
    x = Math.abs(x);

    const t = 1.0 / (1.0 + p * x);
    const y = 1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * Math.exp(-x * x);

    return sign * y;
  }

  // Get option chain with Greeks
  async getOptionChainWithGreeks(symbol = 'NIFTY', expiry = null) {
    try {
      // Get instrument master
      const instruments = await this.getInstrumentMaster();
      if (!instruments) return null;

      // Filter options for the symbol
      const options = instruments.filter(inst => 
        inst.name === symbol && 
        inst.instrumenttype === 'OPTIDX' &&
        (expiry ? inst.expiry === expiry : true)
      );

      const results = [];
      const underlyingPrice = 25000; // You'd get this from LTP API
      const riskFreeRate = 0.06; // 6% risk-free rate
      const volatility = 0.15; // 15% volatility

      for (const option of options.slice(0, 10)) { // Limit for demo
        try {
          // Get LTP for this option
          const ltpData = await this.getLTPData('NFO', option.symbol, option.token);
          
          if (ltpData && ltpData.status) {
            const currentPrice = ltpData.data.ltp;
            const timeToExpiry = this.calculateTimeToExpiry(option.expiry);
            const optionType = option.symbol.includes('CE') ? 'call' : 'put';

            // Calculate Greeks
            const greeks = this.calculateGreeks(
              underlyingPrice,
              parseFloat(option.strike),
              timeToExpiry,
              riskFreeRate,
              volatility,
              optionType
            );

            results.push({
              symbol: option.symbol,
              strike: option.strike,
              expiry: option.expiry,
              optionType: optionType,
              ltp: currentPrice,
              delta: greeks.delta,
              gamma: greeks.gamma,
              theta: greeks.theta,
              vega: greeks.vega
            });
          }

          // Rate limiting
          await this.sleep(100);
        } catch (error) {
          console.error(`Error processing option ${option.symbol}:`, error);
        }
      }

      return results;
    } catch (error) {
      console.error('Option chain fetch failed:', error);
      return null;
    }
  }

  // Calculate time to expiry in years
  calculateTimeToExpiry(expiryDate) {
    const expiry = new Date(expiryDate);
    const now = new Date();
    const diffTime = expiry.getTime() - now.getTime();
    const diffDays = diffTime / (1000 * 60 * 60 * 24);
    return Math.max(diffDays / 365, 0.001); // Minimum 1 day
  }

  // Sleep utility for rate limiting
  sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}

// Usage Example
async function main() {
  const greeksAPI = new AngelOneOptionGreeks(
    'YOUR_API_KEY',
    'YOUR_CLIENT_CODE',
    'YOUR_PIN',
    'YOUR_TOTP_SECRET'
  );

  // Authenticate
  const authenticated = await greeksAPI.authenticate();
  if (!authenticated) {
    console.error('Authentication failed');
    return;
  }

  // Get option chain with Greeks
  const optionChain = await greeksAPI.getOptionChainWithGreeks('NIFTY');
  if (optionChain) {
    console.log('Option Chain with Greeks:');
    console.table(optionChain);
  }
}

// main();
```

### 2. WebSocket Real-time Greeks (Advanced)

```javascript
const WebSocket = require('ws');

class OptionGreeksWebSocket {
  constructor(feedToken, clientCode, apiKey) {
    this.feedToken = feedToken;
    this.clientCode = clientCode;
    this.apiKey = apiKey;
    this.ws = null;
    this.greeksCalculator = new AngelOneOptionGreeks(apiKey, clientCode, '', '');
  }

  connect() {
    const wsUrl = `wss://smartapisocket.angelone.in/smart-stream`;
    this.ws = new WebSocket(wsUrl);

    this.ws.on('open', () => {
      console.log('WebSocket connected');
      this.authenticate();
    });

    this.ws.on('message', (data) => {
      this.handleMessage(data);
    });

    this.ws.on('error', (error) => {
      console.error('WebSocket error:', error);
    });

    this.ws.on('close', () => {
      console.log('WebSocket disconnected');
    });
  }

  authenticate() {
    const authMessage = {
      "a": "auth",
      "user": this.clientCode,
      "token": this.feedToken
    };
    this.ws.send(JSON.stringify(authMessage));
  }

  subscribeToTokens(tokens) {
    const subscribeMessage = {
      "a": "subscribe",
      "v": [[2, tokens]] // NFO exchange
    };
    this.ws.send(JSON.stringify(subscribeMessage));
  }

  handleMessage(data) {
    try {
      const message = JSON.parse(data);
      if (message.ltp) {
        // Calculate Greeks for updated price
        this.calculateAndEmitGreeks(message);
      }
    } catch (error) {
      console.error('Message parsing error:', error);
    }
  }

  calculateAndEmitGreeks(priceData) {
    // Implement real-time Greeks calculation
    const greeks = this.greeksCalculator.calculateGreeks(
      25000, // underlying price
      priceData.strike,
      0.1, // time to expiry
      0.06, // risk-free rate
      0.15, // volatility
      priceData.optionType
    );

    console.log(`Greeks for ${priceData.token}:`, greeks);
  }
}
```

---

## Option Greeks Mathematics

### Black-Scholes Model Implementation

#### Delta (Δ) - Price Sensitivity
```
For Call Options: Δ = N(d1)
For Put Options: Δ = N(d1) - 1

Where:
d1 = [ln(S/K) + (r + σ²/2)T] / (σ√T)
```

#### Gamma (Γ) - Delta Sensitivity
```
For Both Options: Γ = φ(d1) / (S × σ × √T)

Where:
φ(d1) = (1/√(2π)) × e^(-d1²/2)
```

#### Theta (Θ) - Time Decay
```
For Call Options: Θ = -[S×φ(d1)×σ/(2√T) + r×K×e^(-rT)×N(d2)] / 365
For Put Options: Θ = -[S×φ(d1)×σ/(2√T) - r×K×e^(-rT)×N(-d2)] / 365
```

#### Vega (ν) - Volatility Sensitivity
```
For Both Options: ν = S × φ(d1) × √T / 100
```

### Mathematical Constants
```javascript
const TRADING_DAYS_PER_YEAR = 365;
const RISK_FREE_RATE = 0.06; // 6% typical for India
const SQRT_2PI = Math.sqrt(2 * Math.PI);
```

---

## Real-time Integration

### WebSocket Implementation Architecture
```
┌─────────────────────────────────────────────────────────────────┐
│                    Real-time Greeks Pipeline                    │
├─────────────────────────────────────────────────────────────────┤
│  WebSocket Connection                                           │
│  ├── Authentication with Feed Token                            │
│  ├── Token Subscription (up to 1000 symbols)                   │
│  └── Real-time Price Updates                                   │
├─────────────────────────────────────────────────────────────────┤
│  Greeks Calculation Engine                                      │
│  ├── Price Change Detection                                    │
│  ├── Black-Scholes Model Execution                            │
│  ├── Greeks Computation                                        │
│  └── Result Broadcasting                                       │
├─────────────────────────────────────────────────────────────────┤
│  Data Distribution                                              │
│  ├── Frontend UI Updates                                      │
│  ├── Database Storage                                          │
│  └── Alert Generation                                          │
└─────────────────────────────────────────────────────────────────┘
```

### Performance Optimizations
```javascript
class GreeksOptimizer {
  constructor() {
    this.cache = new Map();
    this.batchSize = 100;
    this.updateInterval = 1000; // 1 second
  }

  // Batch Greeks calculations
  batchCalculateGreeks(priceUpdates) {
    const results = [];
    
    for (const update of priceUpdates) {
      const cacheKey = `${update.token}_${update.strike}_${update.expiry}`;
      
      if (this.shouldRecalculate(cacheKey, update)) {
        const greeks = this.calculateGreeks(update);
        this.cache.set(cacheKey, {
          ...greeks,
          timestamp: Date.now(),
          price: update.ltp
        });
        results.push({ ...update, ...greeks });
      }
    }
    
    return results;
  }

  shouldRecalculate(cacheKey, update) {
    const cached = this.cache.get(cacheKey);
    if (!cached) return true;
    
    const priceChange = Math.abs(update.ltp - cached.price) / cached.price;
    const timeElapsed = Date.now() - cached.timestamp;
    
    return priceChange > 0.01 || timeElapsed > this.updateInterval;
  }
}
```

---

## Error Handling & Troubleshooting

### Common Error Codes
```javascript
const ERROR_CODES = {
  'AG8001': 'Invalid Token - Re-authenticate required',
  'AG8002': 'Token Expired - Generate new token',
  'AG8003': 'Token Missing - Check Authorization header',
  'AB1007': 'Login Id or password is invalid',
  'AB1010': 'Session Expired - Re-login required',
  'AB1018': 'Failed to get symbol details',
  'AB2001': 'Internal Error - Retry after some time'
};
```

### Error Handling Implementation
```javascript
class ErrorHandler {
  static handleApiError(error) {
    if (error.response) {
      const errorCode = error.response.data.errorcode;
      const errorMessage = ERROR_CODES[errorCode] || error.response.data.message;
      
      console.error(`API Error [${errorCode}]: ${errorMessage}`);
      
      // Auto-retry logic for specific errors
      if (['AG8001', 'AG8002', 'AB1010'].includes(errorCode)) {
        return 'RETRY_AUTH';
      }
      
      if (errorCode === 'AB2001') {
        return 'RETRY_REQUEST';
      }
    }
    
    return 'FATAL_ERROR';
  }

  static async retryWithBackoff(fn, maxRetries = 3) {
    for (let i = 0; i < maxRetries; i++) {
      try {
        return await fn();
      } catch (error) {
        const action = this.handleApiError(error);
        
        if (action === 'FATAL_ERROR' || i === maxRetries - 1) {
          throw error;
        }
        
        const delay = Math.pow(2, i) * 1000; // Exponential backoff
        await new Promise(resolve => setTimeout(resolve, delay));
      }
    }
  }
}
```

### Rate Limiting Handler
```javascript
class RateLimiter {
  constructor(requestsPerSecond = 10) {
    this.requests = [];
    this.maxRequests = requestsPerSecond;
    this.windowSize = 1000; // 1 second
  }

  async throttle() {
    const now = Date.now();
    
    // Remove old requests outside window
    this.requests = this.requests.filter(
      timestamp => now - timestamp < this.windowSize
    );
    
    if (this.requests.length >= this.maxRequests) {
      const oldestRequest = Math.min(...this.requests);
      const waitTime = this.windowSize - (now - oldestRequest);
      
      if (waitTime > 0) {
        await new Promise(resolve => setTimeout(resolve, waitTime));
      }
    }
    
    this.requests.push(now);
  }
}
```

---

## Best Practices & Optimization

### 1. Caching Strategy
```javascript
class GreeksCache {
  constructor() {
    this.cache = new Map();
    this.ttl = 60000; // 1 minute TTL
  }

  set(key, value) {
    this.cache.set(key, {
      value,
      timestamp: Date.now()
    });
  }

  get(key) {
    const item = this.cache.get(key);
    if (!item) return null;
    
    if (Date.now() - item.timestamp > this.ttl) {
      this.cache.delete(key);
      return null;
    }
    
    return item.value;
  }

  generateKey(symbol, strike, expiry, underlyingPrice) {
    return `${symbol}_${strike}_${expiry}_${Math.round(underlyingPrice)}`;
  }
}
```

### 2. Batch Processing
```javascript
class BatchProcessor {
  constructor(batchSize = 50) {
    this.batchSize = batchSize;
    this.queue = [];
    this.processing = false;
  }

  async addToQueue(items) {
    this.queue.push(...items);
    
    if (!this.processing) {
      this.processing = true;
      await this.processBatch();
      this.processing = false;
    }
  }

  async processBatch() {
    while (this.queue.length > 0) {
      const batch = this.queue.splice(0, this.batchSize);
      await this.processItems(batch);
      
      // Rate limiting
      await new Promise(resolve => setTimeout(resolve, 100));
    }
  }

  async processItems(items) {
    // Process batch of items
    const results = await Promise.all(
      items.map(item => this.processItem(item))
    );
    
    return results;
  }
}
```

### 3. Memory Management
```javascript
class MemoryManager {
  constructor() {
    this.maxCacheSize = 10000;
    this.cleanupInterval = 300000; // 5 minutes
    
    setInterval(() => {
      this.cleanup();
    }, this.cleanupInterval);
  }

  cleanup() {
    // Remove expired cache entries
    global.gc && global.gc(); // Force garbage collection if available
    
    console.log('Memory cleanup completed');
  }

  monitorMemory() {
    const used = process.memoryUsage();
    
    console.log('Memory Usage:');
    for (let key in used) {
      console.log(`${key}: ${Math.round(used[key] / 1024 / 1024 * 100) / 100} MB`);
    }
  }
}
```

---

## Production Deployment

### Environment Configuration
```javascript
const config = {
  development: {
    apiUrl: 'https://apiconnect.angelone.in',
    wsUrl: 'wss://smartapisocket.angelone.in/smart-stream',
    rateLimit: 5, // requests per second
    retryAttempts: 3,
    cacheTimeout: 30000,
    logLevel: 'debug'
  },
  production: {
    apiUrl: 'https://apiconnect.angelone.in',
    wsUrl: 'wss://smartapisocket.angelone.in/smart-stream',
    rateLimit: 10,
    retryAttempts: 5,
    cacheTimeout: 60000,
    logLevel: 'info'
  }
};
```

### Monitoring & Alerting
```javascript
class SystemMonitor {
  constructor() {
    this.metrics = {
      apiCalls: 0,
      errors: 0,
      avgResponseTime: 0,
      activeConnections: 0
    };
    
    this.alerts = [];
  }

  recordApiCall(responseTime) {
    this.metrics.apiCalls++;
    this.metrics.avgResponseTime = 
      (this.metrics.avgResponseTime + responseTime) / 2;
  }

  recordError(error) {
    this.metrics.errors++;
    
    if (this.metrics.errors > 100) {
      this.sendAlert('High error rate detected');
    }
  }

  sendAlert(message) {
    console.error(`ALERT: ${message}`);
    // Implement notification system (email, Slack, etc.)
  }

  getHealthStatus() {
    return {
      status: this.metrics.errors < 10 ? 'healthy' : 'degraded',
      metrics: this.metrics,
      timestamp: new Date().toISOString()
    };
  }
}
```

### Docker Configuration
```dockerfile
FROM node:16-alpine

WORKDIR /app

COPY package*.json ./
RUN npm ci --only=production

COPY . .

EXPOSE 3000

ENV NODE_ENV=production

CMD ["npm", "start"]
```

---

## Advanced Features

### 1. Implied Volatility Calculation
```javascript
class ImpliedVolatilityCalculator {
  calculateIV(marketPrice, S, K, T, r, optionType) {
    let volatility = 0.2; // Initial guess
    let price = this.blackScholesPrice(S, K, T, r, volatility, optionType);
    
    // Newton-Raphson method
    for (let i = 0; i < 100; i++) {
      const vega = this.calculateVega(S, K, T, r, volatility);
      const diff = price - marketPrice;
      
      if (Math.abs(diff) < 0.001) break;
      
      volatility = volatility - (diff / vega);
      price = this.blackScholesPrice(S, K, T, r, volatility, optionType);
    }
    
    return volatility;
  }
}
```

### 2. Greeks Visualization
```javascript
class GreeksVisualizer {
  generateGreeksChart(optionData) {
    const chartData = {
      labels: optionData.map(d => d.strike),
      datasets: [{
        label: 'Delta',
        data: optionData.map(d => d.delta),
        borderColor: 'rgb(75, 192, 192)',
        tension: 0.1
      }, {
        label: 'Gamma',
        data: optionData.map(d => d.gamma),
        borderColor: 'rgb(255, 99, 132)',
        tension: 0.1
      }]
    };
    
    return chartData;
  }
}
```

### 3. Risk Management
```javascript
class RiskManager {
  constructor() {
    this.maxDelta = 1000;
    this.maxGamma = 500;
    this.maxTheta = -1000;
  }

  validatePosition(greeks) {
    const warnings = [];
    
    if (Math.abs(greeks.delta) > this.maxDelta) {
      warnings.push('Delta exposure exceeds limit');
    }
    
    if (Math.abs(greeks.gamma) > this.maxGamma) {
      warnings.push('Gamma exposure exceeds limit');
    }
    
    if (greeks.theta < this.maxTheta) {
      warnings.push('Theta decay exceeds limit');
    }
    
    return warnings;
  }
}
```

---

## Conclusion

This comprehensive documentation provides a complete guide to implementing Angel One SmartAPI Option Greeks functionality. The API provides powerful capabilities for building professional-grade trading applications with real-time Greeks calculations.

### Key Takeaways:
1. **Free Access**: SmartAPI is completely free to use
2. **Real-time Data**: WebSocket integration for live updates
3. **Professional Grade**: Used by institutional traders
4. **Comprehensive**: Covers all major Option Greeks
5. **Multi-language**: Support for various programming languages

### Next Steps:
1. Set up Angel One trading account
2. Generate SmartAPI keys
3. Implement authentication flow
4. Build Greeks calculation engine
5. Add real-time WebSocket integration
6. Deploy to production with monitoring

### Support Resources:
- **Documentation**: https://smartapi.angelbroking.com/docs
- **GitHub**: https://github.com/angel-one/smartapi-python
- **Community**: Angel One Community Forum
- **Support**: SmartAPI technical support team

This documentation should serve as a complete reference for implementing Option Greeks functionality using Angel One SmartAPI.