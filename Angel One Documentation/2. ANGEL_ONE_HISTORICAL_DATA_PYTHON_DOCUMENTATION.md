# Angel One Historical Data API - Complete Python Implementation

## Overview
Comprehensive Python implementation for Angel One Historical Data API, enabling OHLC candlestick data retrieval, technical analysis, and time series processing for local trading platform recreation.

## Core Features
- Historical OHLC data retrieval
- Multiple timeframe support (1min, 5min, 15min, 1hour, 1day)
- Technical indicator calculations
- Data export and analysis
- Volume and price pattern analysis

## API Endpoint
**Base URL:** `https://apiconnect.angelone.in/rest/secure/angelbroking/historical/v1/getCandleData`

## Complete Implementation

```python
import requests
import json
import pandas as pd
import numpy as np
from datetime import datetime, timedelta
import time
from typing import Dict, List, Optional
import ta  # Technical Analysis library

class AngelOneHistoricalData:
    """Complete Angel One Historical Data API implementation"""
    
    def __init__(self, authenticator):
        self.auth = authenticator
        self.base_url = "https://apiconnect.angelone.in"
        
        # Supported intervals
        self.intervals = {
            '1MIN': 'ONE_MINUTE',
            '3MIN': 'THREE_MINUTE', 
            '5MIN': 'FIVE_MINUTE',
            '10MIN': 'TEN_MINUTE',
            '15MIN': 'FIFTEEN_MINUTE',
            '30MIN': 'THIRTY_MINUTE',
            '1HOUR': 'ONE_HOUR',
            '1DAY': 'ONE_DAY'
        }
    
    def get_historical_data(self, 
                          exchange: str,
                          symboltoken: str,
                          interval: str,
                          fromdate: str,
                          todate: str) -> Dict:
        """
        Get historical OHLC data
        
        Args:
            exchange: Exchange (NSE, BSE, NFO, etc.)
            symboltoken: Token of the symbol
            interval: Time interval (1MIN, 5MIN, 15MIN, 1HOUR, 1DAY)
            fromdate: Start date (YYYY-MM-DD HH:MM format)
            todate: End date (YYYY-MM-DD HH:MM format)
        
        Returns:
            Dictionary containing OHLC data
        """
        
        if not self.auth.is_token_valid():
            if not self.auth.refresh_jwt_token():
                raise Exception("Authentication failed")
        
        # Validate interval
        if interval not in self.intervals:
            raise ValueError(f"Invalid interval. Supported: {list(self.intervals.keys())}")
        
        url = f"{self.base_url}/rest/secure/angelbroking/historical/v1/getCandleData"
        
        payload = {
            "exchange": exchange,
            "symboltoken": symboltoken,
            "interval": self.intervals[interval],
            "fromdate": fromdate,
            "todate": todate
        }
        
        try:
            response = requests.post(
                url,
                data=json.dumps(payload),
                headers=self.auth.get_headers(include_auth=True)
            )
            
            if response.status_code == 200:
                data = response.json()
                if data.get('status'):
                    return data['data']
                else:
                    raise Exception(f"Historical data fetch failed: {data.get('message')}")
            else:
                raise Exception(f"HTTP Error: {response.status_code}")
                
        except Exception as e:
            print(f"❌ Historical data error: {str(e)}")
            raise
    
    def get_historical_dataframe(self, 
                               exchange: str,
                               symboltoken: str,
                               interval: str,
                               fromdate: str,
                               todate: str) -> pd.DataFrame:
        """Get historical data as pandas DataFrame"""
        
        data = self.get_historical_data(exchange, symboltoken, interval, fromdate, todate)
        
        if not data:
            return pd.DataFrame()
        
        # Convert to DataFrame
        df = pd.DataFrame(data, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
        
        # Convert timestamp to datetime
        df['timestamp'] = pd.to_datetime(df['timestamp'])
        df.set_index('timestamp', inplace=True)
        
        # Convert to numeric
        numeric_columns = ['open', 'high', 'low', 'close', 'volume']
        df[numeric_columns] = df[numeric_columns].apply(pd.to_numeric, errors='coerce')
        
        return df
    
    def get_multiple_timeframes(self, 
                              exchange: str,
                              symboltoken: str,
                              intervals: List[str],
                              fromdate: str,
                              todate: str) -> Dict[str, pd.DataFrame]:
        """Get data for multiple timeframes"""
        
        result = {}
        
        for interval in intervals:
            try:
                df = self.get_historical_dataframe(exchange, symboltoken, interval, fromdate, todate)
                result[interval] = df
                time.sleep(0.5)  # Rate limiting
            except Exception as e:
                print(f"Error fetching {interval} data: {e}")
                result[interval] = pd.DataFrame()
        
        return result
    
    def get_recent_data(self, 
                       exchange: str,
                       symboltoken: str,
                       interval: str,
                       days: int = 30) -> pd.DataFrame:
        """Get recent historical data for specified number of days"""
        
        # Calculate date range
        end_date = datetime.now()
        start_date = end_date - timedelta(days=days)
        
        fromdate = start_date.strftime('%Y-%m-%d 09:15')
        todate = end_date.strftime('%Y-%m-%d 15:30')
        
        return self.get_historical_dataframe(exchange, symboltoken, interval, fromdate, todate)

class TechnicalAnalysis:
    """Technical analysis tools for historical data"""
    
    @staticmethod
    def add_moving_averages(df: pd.DataFrame, periods: List[int] = [20, 50, 200]) -> pd.DataFrame:
        """Add moving averages to DataFrame"""
        df_copy = df.copy()
        
        for period in periods:
            df_copy[f'SMA_{period}'] = df_copy['close'].rolling(window=period).mean()
            df_copy[f'EMA_{period}'] = df_copy['close'].ewm(span=period).mean()
        
        return df_copy
    
    @staticmethod
    def add_bollinger_bands(df: pd.DataFrame, period: int = 20, std_dev: int = 2) -> pd.DataFrame:
        """Add Bollinger Bands"""
        df_copy = df.copy()
        
        df_copy['BB_SMA'] = df_copy['close'].rolling(window=period).mean()
        df_copy['BB_STD'] = df_copy['close'].rolling(window=period).std()
        df_copy['BB_Upper'] = df_copy['BB_SMA'] + (df_copy['BB_STD'] * std_dev)
        df_copy['BB_Lower'] = df_copy['BB_SMA'] - (df_copy['BB_STD'] * std_dev)
        df_copy['BB_Width'] = df_copy['BB_Upper'] - df_copy['BB_Lower']
        df_copy['BB_Position'] = (df_copy['close'] - df_copy['BB_Lower']) / df_copy['BB_Width']
        
        return df_copy
    
    @staticmethod
    def add_rsi(df: pd.DataFrame, period: int = 14) -> pd.DataFrame:
        """Add RSI indicator"""
        df_copy = df.copy()
        df_copy['RSI'] = ta.momentum.RSIIndicator(df_copy['close'], window=period).rsi()
        return df_copy
    
    @staticmethod
    def add_macd(df: pd.DataFrame, fast: int = 12, slow: int = 26, signal: int = 9) -> pd.DataFrame:
        """Add MACD indicator"""
        df_copy = df.copy()
        
        macd_indicator = ta.trend.MACD(df_copy['close'], window_fast=fast, window_slow=slow, window_sign=signal)
        df_copy['MACD'] = macd_indicator.macd()
        df_copy['MACD_Signal'] = macd_indicator.macd_signal()
        df_copy['MACD_Histogram'] = macd_indicator.macd_diff()
        
        return df_copy
    
    @staticmethod
    def add_stochastic(df: pd.DataFrame, k_period: int = 14, d_period: int = 3) -> pd.DataFrame:
        """Add Stochastic oscillator"""
        df_copy = df.copy()
        
        stoch_indicator = ta.momentum.StochasticOscillator(
            df_copy['high'], df_copy['low'], df_copy['close'], 
            window=k_period, smooth_window=d_period
        )
        df_copy['Stoch_K'] = stoch_indicator.stoch()
        df_copy['Stoch_D'] = stoch_indicator.stoch_signal()
        
        return df_copy
    
    @staticmethod
    def add_volume_indicators(df: pd.DataFrame) -> pd.DataFrame:
        """Add volume-based indicators"""
        df_copy = df.copy()
        
        # Volume SMA
        df_copy['Volume_SMA'] = df_copy['volume'].rolling(window=20).mean()
        
        # Volume ratio
        df_copy['Volume_Ratio'] = df_copy['volume'] / df_copy['Volume_SMA']
        
        # On-Balance Volume
        df_copy['OBV'] = ta.volume.OnBalanceVolumeIndicator(df_copy['close'], df_copy['volume']).on_balance_volume()
        
        # Volume Price Trend
        df_copy['VPT'] = ta.volume.VolumePriceTrendIndicator(df_copy['close'], df_copy['volume']).volume_price_trend()
        
        return df_copy
    
    @staticmethod
    def identify_patterns(df: pd.DataFrame) -> pd.DataFrame:
        """Identify basic candlestick patterns"""
        df_copy = df.copy()
        
        # Calculate body and shadow sizes
        df_copy['Body_Size'] = abs(df_copy['close'] - df_copy['open'])
        df_copy['Upper_Shadow'] = df_copy['high'] - df_copy[['open', 'close']].max(axis=1)
        df_copy['Lower_Shadow'] = df_copy[['open', 'close']].min(axis=1) - df_copy['low']
        df_copy['Total_Range'] = df_copy['high'] - df_copy['low']
        
        # Doji pattern
        df_copy['Doji'] = df_copy['Body_Size'] <= (df_copy['Total_Range'] * 0.1)
        
        # Hammer pattern
        df_copy['Hammer'] = (
            (df_copy['Lower_Shadow'] >= df_copy['Body_Size'] * 2) &
            (df_copy['Upper_Shadow'] <= df_copy['Body_Size'] * 0.1)
        )
        
        # Shooting Star pattern
        df_copy['Shooting_Star'] = (
            (df_copy['Upper_Shadow'] >= df_copy['Body_Size'] * 2) &
            (df_copy['Lower_Shadow'] <= df_copy['Body_Size'] * 0.1)
        )
        
        return df_copy

class DataAnalyzer:
    """Advanced data analysis tools"""
    
    @staticmethod
    def calculate_returns(df: pd.DataFrame) -> pd.DataFrame:
        """Calculate various return metrics"""
        df_copy = df.copy()
        
        # Simple returns
        df_copy['Returns'] = df_copy['close'].pct_change()
        
        # Log returns
        df_copy['Log_Returns'] = np.log(df_copy['close'] / df_copy['close'].shift(1))
        
        # Cumulative returns
        df_copy['Cumulative_Returns'] = (1 + df_copy['Returns']).cumprod() - 1
        
        # Rolling volatility
        df_copy['Volatility_20'] = df_copy['Returns'].rolling(window=20).std() * np.sqrt(252)
        
        return df_copy
    
    @staticmethod
    def calculate_support_resistance(df: pd.DataFrame, window: int = 20) -> Dict:
        """Calculate support and resistance levels"""
        
        # Rolling highs and lows
        rolling_high = df['high'].rolling(window=window, center=True).max()
        rolling_low = df['low'].rolling(window=window, center=True).min()
        
        # Resistance levels (local maxima)
        resistance_levels = df[df['high'] == rolling_high]['high'].unique()
        resistance_levels = np.sort(resistance_levels)[-10:]  # Top 10 levels
        
        # Support levels (local minima)
        support_levels = df[df['low'] == rolling_low]['low'].unique()
        support_levels = np.sort(support_levels)[:10]  # Bottom 10 levels
        
        return {
            'resistance_levels': resistance_levels.tolist(),
            'support_levels': support_levels.tolist(),
            'current_price': df['close'].iloc[-1]
        }
    
    @staticmethod
    def detect_trends(df: pd.DataFrame, window: int = 20) -> pd.DataFrame:
        """Detect trend direction"""
        df_copy = df.copy()
        
        # Simple trend detection using moving averages
        df_copy['SMA_Short'] = df_copy['close'].rolling(window=window//2).mean()
        df_copy['SMA_Long'] = df_copy['close'].rolling(window=window).mean()
        
        # Trend direction
        df_copy['Trend'] = np.where(
            df_copy['SMA_Short'] > df_copy['SMA_Long'], 1,  # Uptrend
            np.where(df_copy['SMA_Short'] < df_copy['SMA_Long'], -1, 0)  # Downtrend, Sideways
        )
        
        # Trend strength
        df_copy['Trend_Strength'] = abs(df_copy['SMA_Short'] - df_copy['SMA_Long']) / df_copy['close']
        
        return df_copy

## Usage Examples

### 1. Basic Historical Data Retrieval

```python
# Initialize historical data client
hist_client = AngelOneHistoricalData(auth)

# Get NIFTY daily data for last 3 months
nifty_data = hist_client.get_recent_data(
    exchange="NSE",
    symboltoken="99926000",  # NIFTY 50 token
    interval="1DAY",
    days=90
)

print(f"📊 NIFTY Data Shape: {nifty_data.shape}")
print(f"📅 Date Range: {nifty_data.index[0]} to {nifty_data.index[-1]}")
print(f"💰 Latest Close: ₹{nifty_data['close'].iloc[-1]:.2f}")

# Display basic statistics
print("\n📈 Basic Statistics:")
print(nifty_data.describe())
```

### 2. Multi-Timeframe Analysis

```python
# Get data for multiple timeframes
symbol_token = "3045"  # SBI token
timeframes = ["5MIN", "15MIN", "1HOUR", "1DAY"]

multi_tf_data = hist_client.get_multiple_timeframes(
    exchange="NSE",
    symboltoken=symbol_token,
    intervals=timeframes,
    fromdate="2024-12-01 09:15",
    todate="2025-01-09 15:30"
)

# Analyze each timeframe
for tf, df in multi_tf_data.items():
    if not df.empty:
        latest_close = df['close'].iloc[-1]
        volume_avg = df['volume'].mean()
        volatility = df['close'].pct_change().std()
        
        print(f"\n📊 {tf} Analysis:")
        print(f"   Latest Price: ₹{latest_close:.2f}")
        print(f"   Avg Volume: {volume_avg:,.0f}")
        print(f"   Volatility: {volatility:.4f}")
```

### 3. Technical Analysis Integration

```python
# Get historical data
df = hist_client.get_recent_data("NSE", "2885", "1DAY", days=200)  # Reliance

# Add technical indicators
ta_analyzer = TechnicalAnalysis()

# Add moving averages
df = ta_analyzer.add_moving_averages(df, [20, 50, 200])

# Add Bollinger Bands
df = ta_analyzer.add_bollinger_bands(df)

# Add RSI
df = ta_analyzer.add_rsi(df)

# Add MACD
df = ta_analyzer.add_macd(df)

# Add Stochastic
df = ta_analyzer.add_stochastic(df)

# Add volume indicators
df = ta_analyzer.add_volume_indicators(df)

# Identify patterns
df = ta_analyzer.identify_patterns(df)

# Display latest technical readings
latest = df.iloc[-1]
print("📊 Latest Technical Analysis:")
print(f"Close: ₹{latest['close']:.2f}")
print(f"SMA 20: ₹{latest['SMA_20']:.2f}")
print(f"SMA 50: ₹{latest['SMA_50']:.2f}")
print(f"SMA 200: ₹{latest['SMA_200']:.2f}")
print(f"RSI: {latest['RSI']:.2f}")
print(f"MACD: {latest['MACD']:.4f}")
print(f"BB Position: {latest['BB_Position']:.2f}")
print(f"Doji: {'Yes' if latest['Doji'] else 'No'}")
print(f"Hammer: {'Yes' if latest['Hammer'] else 'No'}")
```

### 4. Advanced Pattern Recognition

```python
class AdvancedPatterns:
    """Advanced pattern recognition system"""
    
    @staticmethod
    def find_breakouts(df: pd.DataFrame, window: int = 20) -> pd.DataFrame:
        """Find breakout patterns"""
        df_copy = df.copy()
        
        # Calculate resistance and support
        df_copy['Resistance'] = df_copy['high'].rolling(window=window).max()
        df_copy['Support'] = df_copy['low'].rolling(window=window).min()
        
        # Breakout detection
        df_copy['Breakout_Bull'] = (
            (df_copy['close'] > df_copy['Resistance'].shift(1)) &
            (df_copy['volume'] > df_copy['volume'].rolling(window=20).mean())
        )
        
        df_copy['Breakout_Bear'] = (
            (df_copy['close'] < df_copy['Support'].shift(1)) &
            (df_copy['volume'] > df_copy['volume'].rolling(window=20).mean())
        )
        
        return df_copy
    
    @staticmethod
    def find_consolidation(df: pd.DataFrame, window: int = 20, threshold: float = 0.02) -> pd.DataFrame:
        """Find consolidation patterns"""
        df_copy = df.copy()
        
        # Calculate price range
        df_copy['Price_Range'] = (df_copy['high'] - df_copy['low']) / df_copy['close']
        df_copy['Avg_Range'] = df_copy['Price_Range'].rolling(window=window).mean()
        
        # Consolidation detection
        df_copy['Consolidation'] = df_copy['Avg_Range'] < threshold
        
        return df_copy
    
    @staticmethod
    def find_divergences(df: pd.DataFrame) -> pd.DataFrame:
        """Find price-RSI divergences"""
        df_copy = df.copy()
        
        # Calculate RSI if not present
        if 'RSI' not in df_copy.columns:
            df_copy['RSI'] = ta.momentum.RSIIndicator(df_copy['close']).rsi()
        
        # Find local peaks and troughs
        window = 10
        df_copy['Price_Peak'] = df_copy['close'] == df_copy['close'].rolling(window=window, center=True).max()
        df_copy['Price_Trough'] = df_copy['close'] == df_copy['close'].rolling(window=window, center=True).min()
        df_copy['RSI_Peak'] = df_copy['RSI'] == df_copy['RSI'].rolling(window=window, center=True).max()
        df_copy['RSI_Trough'] = df_copy['RSI'] == df_copy['RSI'].rolling(window=window, center=True).min()
        
        # Bullish divergence: Price makes lower low, RSI makes higher low
        # Bearish divergence: Price makes higher high, RSI makes lower high
        
        return df_copy

# Usage
patterns = AdvancedPatterns()

# Find breakouts
df_breakouts = patterns.find_breakouts(df)
recent_breakouts = df_breakouts[df_breakouts['Breakout_Bull'] | df_breakouts['Breakout_Bear']].tail(10)
print("\n🚀 Recent Breakouts:")
print(recent_breakouts[['close', 'volume', 'Breakout_Bull', 'Breakout_Bear']])

# Find consolidation periods
df_consolidation = patterns.find_consolidation(df)
consolidation_periods = df_consolidation[df_consolidation['Consolidation']].tail(10)
print("\n📦 Consolidation Periods:")
print(consolidation_periods[['close', 'Price_Range', 'Avg_Range']])
```

### 5. Backtesting Framework

```python
class SimpleBacktester:
    """Simple backtesting framework"""
    
    def __init__(self, initial_capital: float = 100000):
        self.initial_capital = initial_capital
        self.capital = initial_capital
        self.position = 0
        self.trades = []
        self.equity_curve = []
    
    def add_signal(self, df: pd.DataFrame, signal_column: str) -> pd.DataFrame:
        """Add trading signals to DataFrame"""
        df_copy = df.copy()
        
        # Simple moving average crossover strategy
        df_copy['Signal'] = 0
        df_copy.loc[df_copy['SMA_20'] > df_copy['SMA_50'], 'Signal'] = 1  # Buy signal
        df_copy.loc[df_copy['SMA_20'] < df_copy['SMA_50'], 'Signal'] = -1  # Sell signal
        
        return df_copy
    
    def backtest_strategy(self, df: pd.DataFrame) -> Dict:
        """Run backtest on strategy"""
        df_signals = self.add_signal(df, 'Signal')
        
        for i, row in df_signals.iterrows():
            current_signal = row['Signal']
            current_price = row['close']
            
            # Entry logic
            if current_signal == 1 and self.position <= 0:  # Buy signal
                if self.position < 0:  # Close short position
                    self._close_position(current_price, i, 'cover')
                self._open_position(current_price, i, 'long')
            
            elif current_signal == -1 and self.position >= 0:  # Sell signal
                if self.position > 0:  # Close long position
                    self._close_position(current_price, i, 'sell')
                self._open_position(current_price, i, 'short')
            
            # Track equity
            if self.position > 0:
                position_value = self.position * current_price
            elif self.position < 0:
                position_value = self.capital + (self.position * current_price)
            else:
                position_value = self.capital
            
            self.equity_curve.append({
                'date': i,
                'equity': position_value,
                'price': current_price
            })
        
        return self._calculate_performance()
    
    def _open_position(self, price: float, date, position_type: str):
        """Open new position"""
        if position_type == 'long':
            shares = int(self.capital / price)
            self.position = shares
            self.capital -= shares * price
        else:  # short
            shares = int(self.capital / price)
            self.position = -shares
            # For short positions, we keep cash and owe shares
        
        self.trades.append({
            'date': date,
            'type': 'open',
            'position_type': position_type,
            'price': price,
            'shares': abs(self.position)
        })
    
    def _close_position(self, price: float, date, action: str):
        """Close existing position"""
        if self.position != 0:
            if action in ['sell', 'cover']:
                if self.position > 0:  # Closing long
                    self.capital += self.position * price
                else:  # Closing short
                    self.capital += abs(self.position) * price
                
                self.trades.append({
                    'date': date,
                    'type': 'close',
                    'action': action,
                    'price': price,
                    'shares': abs(self.position)
                })
                
                self.position = 0
    
    def _calculate_performance(self) -> Dict:
        """Calculate performance metrics"""
        equity_df = pd.DataFrame(self.equity_curve)
        
        if len(equity_df) == 0:
            return {}
        
        final_equity = equity_df['equity'].iloc[-1]
        total_return = (final_equity - self.initial_capital) / self.initial_capital * 100
        
        # Calculate daily returns
        equity_df['returns'] = equity_df['equity'].pct_change()
        
        # Performance metrics
        winning_trades = len([t for t in self.trades if t['type'] == 'close' and t.get('profit', 0) > 0])
        total_trades = len([t for t in self.trades if t['type'] == 'close'])
        win_rate = winning_trades / total_trades * 100 if total_trades > 0 else 0
        
        return {
            'initial_capital': self.initial_capital,
            'final_equity': final_equity,
            'total_return_percent': total_return,
            'total_trades': total_trades,
            'winning_trades': winning_trades,
            'win_rate_percent': win_rate,
            'equity_curve': equity_df,
            'trades': self.trades
        }

# Backtest example
# Add technical indicators first
df_with_ta = ta_analyzer.add_moving_averages(df, [20, 50])

# Run backtest
backtester = SimpleBacktester(initial_capital=100000)
results = backtester.backtest_strategy(df_with_ta)

print("\n📊 Backtest Results:")
print(f"Initial Capital: ₹{results['initial_capital']:,.2f}")
print(f"Final Equity: ₹{results['final_equity']:,.2f}")
print(f"Total Return: {results['total_return_percent']:.2f}%")
print(f"Total Trades: {results['total_trades']}")
print(f"Win Rate: {results['win_rate_percent']:.2f}%")
```

### 6. Data Export and Visualization

```python
import matplotlib.pyplot as plt
import seaborn as sns

class DataVisualizer:
    """Data visualization tools"""
    
    @staticmethod
    def plot_price_with_indicators(df: pd.DataFrame, title: str = "Price Analysis"):
        """Plot price with technical indicators"""
        fig, (ax1, ax2, ax3) = plt.subplots(3, 1, figsize=(15, 12), sharex=True)
        
        # Price and moving averages
        ax1.plot(df.index, df['close'], label='Close', linewidth=2)
        if 'SMA_20' in df.columns:
            ax1.plot(df.index, df['SMA_20'], label='SMA 20', alpha=0.7)
        if 'SMA_50' in df.columns:
            ax1.plot(df.index, df['SMA_50'], label='SMA 50', alpha=0.7)
        if 'BB_Upper' in df.columns:
            ax1.plot(df.index, df['BB_Upper'], label='BB Upper', alpha=0.5)
            ax1.plot(df.index, df['BB_Lower'], label='BB Lower', alpha=0.5)
            ax1.fill_between(df.index, df['BB_Upper'], df['BB_Lower'], alpha=0.1)
        
        ax1.set_title(title)
        ax1.legend()
        ax1.grid(True, alpha=0.3)
        
        # Volume
        ax2.bar(df.index, df['volume'], alpha=0.7, color='blue')
        if 'Volume_SMA' in df.columns:
            ax2.plot(df.index, df['Volume_SMA'], color='red', label='Volume SMA')
        ax2.set_title('Volume')
        ax2.legend()
        ax2.grid(True, alpha=0.3)
        
        # RSI
        if 'RSI' in df.columns:
            ax3.plot(df.index, df['RSI'], label='RSI', color='purple')
            ax3.axhline(y=70, color='r', linestyle='--', alpha=0.7, label='Overbought')
            ax3.axhline(y=30, color='g', linestyle='--', alpha=0.7, label='Oversold')
            ax3.fill_between(df.index, 30, 70, alpha=0.1)
            ax3.set_ylim(0, 100)
            ax3.set_title('RSI')
            ax3.legend()
            ax3.grid(True, alpha=0.3)
        
        plt.tight_layout()
        plt.show()
    
    @staticmethod
    def export_to_csv(df: pd.DataFrame, filename: str):
        """Export DataFrame to CSV"""
        df.to_csv(filename)
        print(f"📁 Data exported to {filename}")
    
    @staticmethod
    def generate_report(df: pd.DataFrame, symbol: str) -> str:
        """Generate analysis report"""
        latest = df.iloc[-1]
        prev = df.iloc[-2] if len(df) > 1 else latest
        
        price_change = latest['close'] - prev['close']
        price_change_pct = (price_change / prev['close']) * 100
        
        report = f"""
📊 Analysis Report for {symbol}
{'=' * 50}

💰 Price Information:
   Current Price: ₹{latest['close']:.2f}
   Previous Close: ₹{prev['close']:.2f}
   Change: ₹{price_change:.2f} ({price_change_pct:+.2f}%)
   Volume: {latest['volume']:,}

📈 Technical Indicators:
"""
        
        if 'SMA_20' in df.columns:
            report += f"   SMA 20: ₹{latest['SMA_20']:.2f}\n"
        if 'SMA_50' in df.columns:
            report += f"   SMA 50: ₹{latest['SMA_50']:.2f}\n"
        if 'RSI' in df.columns:
            report += f"   RSI: {latest['RSI']:.2f}\n"
        if 'MACD' in df.columns:
            report += f"   MACD: {latest['MACD']:.4f}\n"
        
        # Support/Resistance
        analyzer = DataAnalyzer()
        sr_levels = analyzer.calculate_support_resistance(df)
        
        report += f"""
🎯 Support & Resistance:
   Nearest Support: ₹{max([s for s in sr_levels['support_levels'] if s < latest['close']], default=0):.2f}
   Nearest Resistance: ₹{min([r for r in sr_levels['resistance_levels'] if r > latest['close']], default=0):.2f}

📊 Statistics (Last 30 days):
   High: ₹{df['high'].tail(30).max():.2f}
   Low: ₹{df['low'].tail(30).min():.2f}
   Avg Volume: {df['volume'].tail(30).mean():,.0f}
   Volatility: {df['close'].tail(30).pct_change().std():.4f}
"""
        
        return report

# Usage examples
visualizer = DataVisualizer()

# Plot with indicators
visualizer.plot_price_with_indicators(df, "RELIANCE - Technical Analysis")

# Export data
visualizer.export_to_csv(df, "reliance_historical_data.csv")

# Generate report
report = visualizer.generate_report(df, "RELIANCE")
print(report)
```

This comprehensive Historical Data API documentation provides:

1. **Complete API implementation** with proper authentication and error handling
2. **Multi-timeframe data retrieval** for various analysis needs
3. **Technical analysis integration** with popular indicators
4. **Advanced pattern recognition** for trading signals
5. **Backtesting framework** for strategy validation
6. **Data visualization tools** for chart analysis
7. **Export capabilities** for further analysis

The implementation is designed for local recreation and includes all necessary components for building a complete historical data analysis system.