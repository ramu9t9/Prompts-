# Angel One Portfolio & Margin APIs - Complete Python Implementation

## Overview
Comprehensive Python implementation for Angel One Portfolio Management and Margin Calculator APIs, enabling complete position tracking, holdings management, and margin calculations for local trading platform recreation.

## Core Features
- Holdings and positions management
- Position conversion capabilities
- Real-time P&L tracking
- Margin requirement calculations
- Risk assessment tools
- Portfolio performance analytics

## API Endpoints Coverage

### Portfolio APIs
1. **Holdings**: `GET /rest/secure/angelbroking/portfolio/v1/getHolding`
2. **All Holdings**: `GET /rest/secure/angelbroking/portfolio/v1/getAllHolding`
3. **Positions**: `GET /rest/secure/angelbroking/portfolio/v1/getPosition`
4. **Position Conversion**: `POST /rest/secure/angelbroking/portfolio/v1/convertPosition`

### Margin APIs
5. **Margin Calculator**: `POST /rest/secure/angelbroking/margin/v1/batch`
6. **Funds & Margins**: `GET /rest/secure/angelbroking/user/v1/getRMS`

## Complete Implementation

```python
import requests
import json
import pandas as pd
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Tuple
import numpy as np

class AngelOnePortfolio:
    """Complete Angel One Portfolio Management implementation"""
    
    def __init__(self, authenticator):
        self.auth = authenticator
        self.base_url = "https://apiconnect.angelone.in"
        
        # Position types
        self.position_types = {
            'DELIVERY': 'CNC',
            'INTRADAY': 'MIS', 
            'CARRYFORWARD': 'NRML',
            'MARGIN': 'MIS'
        }
    
    def get_holdings(self) -> List[Dict]:
        """Get all holdings (delivery positions)"""
        
        if not self.auth.is_token_valid():
            if not self.auth.refresh_jwt_token():
                raise Exception("Authentication failed")
        
        url = f"{self.base_url}/rest/secure/angelbroking/portfolio/v1/getHolding"
        
        try:
            response = requests.get(
                url,
                headers=self.auth.get_headers(include_auth=True)
            )
            
            if response.status_code == 200:
                data = response.json()
                if data.get('status'):
                    return data['data']
                else:
                    raise Exception(f"Holdings fetch failed: {data.get('message')}")
            else:
                raise Exception(f"HTTP Error: {response.status_code}")
                
        except Exception as e:
            print(f"‚ùå Holdings fetch error: {str(e)}")
            raise
    
    def get_all_holdings(self) -> List[Dict]:
        """Get detailed holdings with additional metrics"""
        
        if not self.auth.is_token_valid():
            if not self.auth.refresh_jwt_token():
                raise Exception("Authentication failed")
        
        url = f"{self.base_url}/rest/secure/angelbroking/portfolio/v1/getAllHolding"
        
        try:
            response = requests.get(
                url,
                headers=self.auth.get_headers(include_auth=True)
            )
            
            if response.status_code == 200:
                data = response.json()
                if data.get('status'):
                    return data['data']
                else:
                    raise Exception(f"All holdings fetch failed: {data.get('message')}")
            else:
                raise Exception(f"HTTP Error: {response.status_code}")
                
        except Exception as e:
            print(f"‚ùå All holdings fetch error: {str(e)}")
            raise
    
    def get_positions(self) -> Dict:
        """Get all positions (day and net)"""
        
        if not self.auth.is_token_valid():
            if not self.auth.refresh_jwt_token():
                raise Exception("Authentication failed")
        
        url = f"{self.base_url}/rest/secure/angelbroking/portfolio/v1/getPosition"
        
        try:
            response = requests.get(
                url,
                headers=self.auth.get_headers(include_auth=True)
            )
            
            if response.status_code == 200:
                data = response.json()
                if data.get('status'):
                    return data['data']
                else:
                    raise Exception(f"Positions fetch failed: {data.get('message')}")
            else:
                raise Exception(f"HTTP Error: {response.status_code}")
                
        except Exception as e:
            print(f"‚ùå Positions fetch error: {str(e)}")
            raise
    
    def convert_position(self, 
                        exchange: str,
                        oldproducttype: str,
                        newproducttype: str,
                        tradingsymbol: str,
                        transactiontype: str,
                        quantity: int,
                        type: str) -> Dict:
        """
        Convert position from one product type to another
        
        Args:
            exchange: Exchange (NSE, BSE, NFO, etc.)
            oldproducttype: Current product type (DELIVERY, INTRADAY, etc.)
            newproducttype: Target product type
            tradingsymbol: Trading symbol
            transactiontype: BUY or SELL
            quantity: Quantity to convert
            type: Position type
        """
        
        if not self.auth.is_token_valid():
            if not self.auth.refresh_jwt_token():
                raise Exception("Authentication failed")
        
        url = f"{self.base_url}/rest/secure/angelbroking/portfolio/v1/convertPosition"
        
        payload = {
            "exchange": exchange,
            "oldproducttype": oldproducttype,
            "newproducttype": newproducttype,
            "tradingsymbol": tradingsymbol,
            "transactiontype": transactiontype,
            "quantity": quantity,
            "type": type
        }
        
        try:
            response = requests.post(
                url,
                data=json.dumps(payload),
                headers=self.auth.get_headers(include_auth=True)
            )
            
            if response.status_code == 200:
                data = response.json()
                if data.get('status'):
                    print(f"‚úÖ Position converted successfully")
                    return data['data']
                else:
                    raise Exception(f"Position conversion failed: {data.get('message')}")
            else:
                raise Exception(f"HTTP Error: {response.status_code}")
                
        except Exception as e:
            print(f"‚ùå Position conversion error: {str(e)}")
            raise
    
    def get_funds_and_margins(self) -> Dict:
        """Get funds and margin information"""
        
        if not self.auth.is_token_valid():
            if not self.auth.refresh_jwt_token():
                raise Exception("Authentication failed")
        
        url = f"{self.base_url}/rest/secure/angelbroking/user/v1/getRMS"
        
        try:
            response = requests.get(
                url,
                headers=self.auth.get_headers(include_auth=True)
            )
            
            if response.status_code == 200:
                data = response.json()
                if data.get('status'):
                    return data['data']
                else:
                    raise Exception(f"Funds fetch failed: {data.get('message')}")
            else:
                raise Exception(f"HTTP Error: {response.status_code}")
                
        except Exception as e:
            print(f"‚ùå Funds fetch error: {str(e)}")
            raise

class AngelOneMarginCalculator:
    """Angel One Margin Calculator implementation"""
    
    def __init__(self, authenticator):
        self.auth = authenticator
        self.base_url = "https://apiconnect.angelone.in"
    
    def calculate_margin(self, orders: List[Dict]) -> Dict:
        """
        Calculate margin requirement for orders
        
        Args:
            orders: List of order dictionaries with required fields
        """
        
        if not self.auth.is_token_valid():
            if not self.auth.refresh_jwt_token():
                raise Exception("Authentication failed")
        
        url = f"{self.base_url}/rest/secure/angelbroking/margin/v1/batch"
        
        payload = {"orders": orders}
        
        try:
            response = requests.post(
                url,
                data=json.dumps(payload),
                headers=self.auth.get_headers(include_auth=True)
            )
            
            if response.status_code == 200:
                data = response.json()
                if data.get('status'):
                    return data['data']
                else:
                    raise Exception(f"Margin calculation failed: {data.get('message')}")
            else:
                raise Exception(f"HTTP Error: {response.status_code}")
                
        except Exception as e:
            print(f"‚ùå Margin calculation error: {str(e)}")
            raise
    
    def calculate_single_order_margin(self, 
                                    exchange: str,
                                    tradingsymbol: str,
                                    quantity: int,
                                    price: float,
                                    product: str = "MIS",
                                    transactiontype: str = "BUY") -> Dict:
        """Calculate margin for a single order"""
        
        order = {
            "exchange": exchange,
            "tradingsymbol": tradingsymbol,
            "quantity": str(quantity),
            "price": str(price),
            "product": product,
            "transactiontype": transactiontype
        }
        
        return self.calculate_margin([order])

class PortfolioAnalyzer:
    """Advanced portfolio analysis tools"""
    
    def __init__(self, portfolio_client: AngelOnePortfolio):
        self.portfolio_client = portfolio_client
    
    def get_portfolio_summary(self) -> Dict:
        """Get comprehensive portfolio summary"""
        
        # Get all data
        holdings = self.portfolio_client.get_holdings()
        positions = self.portfolio_client.get_positions()
        funds = self.portfolio_client.get_funds_and_margins()
        
        # Process holdings
        holdings_df = pd.DataFrame(holdings) if holdings else pd.DataFrame()
        holdings_summary = self._analyze_holdings(holdings_df)
        
        # Process positions
        day_positions = positions.get('day', [])
        net_positions = positions.get('net', [])
        
        day_positions_df = pd.DataFrame(day_positions) if day_positions else pd.DataFrame()
        net_positions_df = pd.DataFrame(net_positions) if net_positions else pd.DataFrame()
        
        positions_summary = self._analyze_positions(day_positions_df, net_positions_df)
        
        # Overall summary
        total_investment = holdings_summary.get('total_investment', 0)
        total_current_value = holdings_summary.get('total_current_value', 0)
        day_pnl = positions_summary.get('day_pnl', 0)
        net_pnl = positions_summary.get('net_pnl', 0)
        
        return {
            'timestamp': datetime.now(),
            'funds': funds,
            'holdings_summary': holdings_summary,
            'positions_summary': positions_summary,
            'overall_pnl': {
                'holdings_pnl': total_current_value - total_investment,
                'day_pnl': day_pnl,
                'net_pnl': net_pnl,
                'total_pnl': (total_current_value - total_investment) + net_pnl
            },
            'raw_data': {
                'holdings': holdings,
                'day_positions': day_positions,
                'net_positions': net_positions
            }
        }
    
    def _analyze_holdings(self, holdings_df: pd.DataFrame) -> Dict:
        """Analyze holdings data"""
        
        if holdings_df.empty:
            return {
                'total_holdings': 0,
                'total_investment': 0,
                'total_current_value': 0,
                'total_pnl': 0,
                'top_holdings': [],
                'sector_allocation': {}
            }
        
        # Convert numeric columns
        numeric_cols = ['quantity', 'averageprice', 'ltp', 'profitandloss', 'pnlpercentage']
        for col in numeric_cols:
            if col in holdings_df.columns:
                holdings_df[col] = pd.to_numeric(holdings_df[col], errors='coerce')
        
        # Calculate metrics
        total_investment = (holdings_df['quantity'] * holdings_df['averageprice']).sum()
        total_current_value = (holdings_df['quantity'] * holdings_df['ltp']).sum()
        total_pnl = holdings_df['profitandloss'].sum()
        
        # Top holdings by value
        holdings_df['current_value'] = holdings_df['quantity'] * holdings_df['ltp']
        top_holdings = holdings_df.nlargest(10, 'current_value')[
            ['tradingsymbol', 'quantity', 'averageprice', 'ltp', 'profitandloss', 'current_value']
        ].to_dict('records')
        
        return {
            'total_holdings': len(holdings_df),
            'total_investment': total_investment,
            'total_current_value': total_current_value,
            'total_pnl': total_pnl,
            'total_pnl_percentage': (total_pnl / total_investment * 100) if total_investment > 0 else 0,
            'top_holdings': top_holdings
        }
    
    def _analyze_positions(self, day_positions_df: pd.DataFrame, net_positions_df: pd.DataFrame) -> Dict:
        """Analyze positions data"""
        
        day_summary = self._analyze_single_position_type(day_positions_df, "Day")
        net_summary = self._analyze_single_position_type(net_positions_df, "Net")
        
        return {
            'day_positions': day_summary,
            'net_positions': net_summary,
            'day_pnl': day_summary.get('total_pnl', 0),
            'net_pnl': net_summary.get('total_pnl', 0)
        }
    
    def _analyze_single_position_type(self, positions_df: pd.DataFrame, position_type: str) -> Dict:
        """Analyze single position type (day or net)"""
        
        if positions_df.empty:
            return {
                'total_positions': 0,
                'total_pnl': 0,
                'profitable_positions': 0,
                'loss_positions': 0,
                'largest_profit': 0,
                'largest_loss': 0,
                'positions': []
            }
        
        # Convert numeric columns
        numeric_cols = ['buyqty', 'sellqty', 'netqty', 'buyavgprice', 'sellavgprice', 'ltp', 'pnl']
        for col in numeric_cols:
            if col in positions_df.columns:
                positions_df[col] = pd.to_numeric(positions_df[col], errors='coerce')
        
        total_pnl = positions_df['pnl'].sum()
        profitable_positions = len(positions_df[positions_df['pnl'] > 0])
        loss_positions = len(positions_df[positions_df['pnl'] < 0])
        largest_profit = positions_df['pnl'].max() if not positions_df.empty else 0
        largest_loss = positions_df['pnl'].min() if not positions_df.empty else 0
        
        # Get position details
        positions_list = positions_df[
            ['tradingsymbol', 'netqty', 'buyavgprice', 'sellavgprice', 'ltp', 'pnl']
        ].to_dict('records')
        
        return {
            'total_positions': len(positions_df),
            'total_pnl': total_pnl,
            'profitable_positions': profitable_positions,
            'loss_positions': loss_positions,
            'largest_profit': largest_profit,
            'largest_loss': largest_loss,
            'win_rate': (profitable_positions / len(positions_df) * 100) if len(positions_df) > 0 else 0,
            'positions': positions_list
        }
    
    def generate_portfolio_report(self) -> str:
        """Generate comprehensive portfolio report"""
        
        summary = self.get_portfolio_summary()
        
        report = f"""
üìä Portfolio Analysis Report
{'=' * 50}
üìÖ Generated: {summary['timestamp'].strftime('%Y-%m-%d %H:%M:%S')}

üí∞ FUNDS & MARGINS:
   Available Cash: ‚Çπ{summary['funds'].get('availablecash', 0):,.2f}
   Used Margin: ‚Çπ{summary['funds'].get('collateral', 0):,.2f}
   Total Margin: ‚Çπ{summary['funds'].get('utiliseddebits', 0):,.2f}

üè¶ HOLDINGS SUMMARY:
   Total Holdings: {summary['holdings_summary']['total_holdings']}
   Total Investment: ‚Çπ{summary['holdings_summary']['total_investment']:,.2f}
   Current Value: ‚Çπ{summary['holdings_summary']['total_current_value']:,.2f}
   Holdings P&L: ‚Çπ{summary['holdings_summary']['total_pnl']:,.2f} ({summary['holdings_summary']['total_pnl_percentage']:+.2f}%)

üìà POSITIONS SUMMARY:
   Day P&L: ‚Çπ{summary['positions_summary']['day_pnl']:,.2f}
   Net P&L: ‚Çπ{summary['positions_summary']['net_pnl']:,.2f}
   Day Positions: {summary['positions_summary']['day_positions']['total_positions']}
   Net Positions: {summary['positions_summary']['net_positions']['total_positions']}

üéØ OVERALL PERFORMANCE:
   Total Portfolio P&L: ‚Çπ{summary['overall_pnl']['total_pnl']:,.2f}
   Day Win Rate: {summary['positions_summary']['day_positions']['win_rate']:.1f}%
   Net Win Rate: {summary['positions_summary']['net_positions']['win_rate']:.1f}%

üîù TOP HOLDINGS:
"""
        
        for i, holding in enumerate(summary['holdings_summary']['top_holdings'][:5], 1):
            report += f"   {i}. {holding['tradingsymbol']}: ‚Çπ{holding['current_value']:,.2f} (P&L: ‚Çπ{holding['profitandloss']:,.2f})\n"
        
        return report

class RiskManager:
    """Portfolio risk management tools"""
    
    def __init__(self, portfolio_analyzer: PortfolioAnalyzer, margin_calculator: AngelOneMarginCalculator):
        self.portfolio_analyzer = portfolio_analyzer
        self.margin_calculator = margin_calculator
    
    def calculate_portfolio_risk(self) -> Dict:
        """Calculate portfolio risk metrics"""
        
        summary = self.portfolio_analyzer.get_portfolio_summary()
        
        # Extract data
        total_investment = summary['holdings_summary']['total_investment']
        total_current_value = summary['holdings_summary']['total_current_value']
        day_pnl = summary['positions_summary']['day_pnl']
        available_cash = summary['funds'].get('availablecash', 0)
        used_margin = summary['funds'].get('utiliseddebits', 0)
        
        # Risk calculations
        portfolio_value = total_current_value + available_cash
        leverage_ratio = used_margin / portfolio_value if portfolio_value > 0 else 0
        concentration_risk = self._calculate_concentration_risk(summary['holdings_summary']['top_holdings'])
        
        # VaR estimation (simplified)
        daily_returns = self._estimate_daily_returns(summary)
        var_95 = np.percentile(daily_returns, 5) if daily_returns else 0
        
        return {
            'portfolio_value': portfolio_value,
            'leverage_ratio': leverage_ratio,
            'concentration_risk': concentration_risk,
            'value_at_risk_95': var_95,
            'margin_utilization': (used_margin / (used_margin + available_cash)) * 100 if (used_margin + available_cash) > 0 else 0,
            'risk_score': self._calculate_risk_score(leverage_ratio, concentration_risk, var_95)
        }
    
    def _calculate_concentration_risk(self, top_holdings: List[Dict]) -> float:
        """Calculate concentration risk based on top holdings"""
        
        if not top_holdings:
            return 0
        
        total_value = sum(holding['current_value'] for holding in top_holdings)
        top_3_value = sum(holding['current_value'] for holding in top_holdings[:3])
        
        return (top_3_value / total_value * 100) if total_value > 0 else 0
    
    def _estimate_daily_returns(self, summary: Dict) -> List[float]:
        """Estimate daily returns for VaR calculation"""
        # Simplified approach - in real implementation, use historical price data
        holdings = summary['holdings_summary']['top_holdings']
        
        daily_returns = []
        for holding in holdings:
            if 'pnlpercentage' in holding:
                # Assume this is a rough daily return estimate
                daily_returns.append(holding.get('pnlpercentage', 0))
        
        return daily_returns
    
    def _calculate_risk_score(self, leverage: float, concentration: float, var: float) -> int:
        """Calculate overall risk score (1-10, 10 being highest risk)"""
        
        score = 1
        
        # Leverage component
        if leverage > 0.8:
            score += 3
        elif leverage > 0.5:
            score += 2
        elif leverage > 0.3:
            score += 1
        
        # Concentration component
        if concentration > 60:
            score += 3
        elif concentration > 40:
            score += 2
        elif concentration > 25:
            score += 1
        
        # VaR component
        if abs(var) > 5:
            score += 3
        elif abs(var) > 3:
            score += 2
        elif abs(var) > 2:
            score += 1
        
        return min(score, 10)
    
    def check_margin_requirements(self, planned_orders: List[Dict]) -> Dict:
        """Check if planned orders can be executed with available margin"""
        
        # Get current funds
        summary = self.portfolio_analyzer.get_portfolio_summary()
        available_cash = summary['funds'].get('availablecash', 0)
        
        # Calculate margin requirement for planned orders
        try:
            margin_result = self.margin_calculator.calculate_margin(planned_orders)
            required_margin = margin_result.get('required_margin', 0)
            
            can_execute = available_cash >= required_margin
            margin_shortfall = max(0, required_margin - available_cash)
            
            return {
                'can_execute': can_execute,
                'available_cash': available_cash,
                'required_margin': required_margin,
                'margin_shortfall': margin_shortfall,
                'utilization_after_orders': ((required_margin / available_cash) * 100) if available_cash > 0 else 0
            }
            
        except Exception as e:
            print(f"Margin check error: {e}")
            return {
                'can_execute': False,
                'error': str(e)
            }

## Usage Examples

### 1. Basic Portfolio Operations

```python
# Initialize portfolio client
portfolio_client = AngelOnePortfolio(auth)

# Get holdings
holdings = portfolio_client.get_holdings()
print(f"üì¶ Total Holdings: {len(holdings)}")

for holding in holdings[:5]:  # Show first 5
    print(f"   {holding['tradingsymbol']}: {holding['quantity']} @ ‚Çπ{holding['averageprice']} (P&L: ‚Çπ{holding['profitandloss']})")

# Get positions
positions = portfolio_client.get_positions()
day_positions = positions.get('day', [])
net_positions = positions.get('net', [])

print(f"\nüìä Day Positions: {len(day_positions)}")
print(f"üìä Net Positions: {len(net_positions)}")

# Get funds and margins
funds = portfolio_client.get_funds_and_margins()
print(f"\nüí∞ Available Cash: ‚Çπ{funds.get('availablecash', 0):,.2f}")
print(f"üí∞ Used Margin: ‚Çπ{funds.get('utiliseddebits', 0):,.2f}")
```

### 2. Position Conversion

```python
# Convert intraday position to delivery
try:
    conversion_result = portfolio_client.convert_position(
        exchange="NSE",
        oldproducttype="INTRADAY",
        newproducttype="DELIVERY", 
        tradingsymbol="SBIN-EQ",
        transactiontype="BUY",
        quantity=100,
        type="DAY"
    )
    print("‚úÖ Position converted successfully")
except Exception as e:
    print(f"‚ùå Conversion failed: {e}")
```

### 3. Margin Calculations

```python
# Initialize margin calculator
margin_calc = AngelOneMarginCalculator(auth)

# Calculate margin for single order
margin_result = margin_calc.calculate_single_order_margin(
    exchange="NSE",
    tradingsymbol="RELIANCE-EQ",
    quantity=10,
    price=2650.0,
    product="MIS",
    transactiontype="BUY"
)

print(f"üìä Required Margin: ‚Çπ{margin_result.get('required_margin', 0):,.2f}")

# Calculate margin for multiple orders
orders = [
    {
        "exchange": "NSE",
        "tradingsymbol": "SBIN-EQ",
        "quantity": "100",
        "price": "520.0",
        "product": "MIS",
        "transactiontype": "BUY"
    },
    {
        "exchange": "NSE", 
        "tradingsymbol": "TCS-EQ",
        "quantity": "25",
        "price": "3200.0",
        "product": "MIS",
        "transactiontype": "BUY"
    }
]

batch_margin = margin_calc.calculate_margin(orders)
print(f"üìä Total Margin Required: ‚Çπ{batch_margin.get('total_margin', 0):,.2f}")
```

### 4. Portfolio Analysis

```python
# Initialize portfolio analyzer
analyzer = PortfolioAnalyzer(portfolio_client)

# Get comprehensive portfolio summary
summary = analyzer.get_portfolio_summary()

print("üìä Portfolio Summary:")
print(f"   Total Investment: ‚Çπ{summary['holdings_summary']['total_investment']:,.2f}")
print(f"   Current Value: ‚Çπ{summary['holdings_summary']['total_current_value']:,.2f}")
print(f"   Total P&L: ‚Çπ{summary['overall_pnl']['total_pnl']:,.2f}")

# Generate detailed report
report = analyzer.generate_portfolio_report()
print(report)
```

### 5. Risk Management

```python
# Initialize risk manager
risk_mgr = RiskManager(analyzer, margin_calc)

# Calculate portfolio risk
risk_metrics = risk_mgr.calculate_portfolio_risk()

print("üéØ Risk Analysis:")
print(f"   Portfolio Value: ‚Çπ{risk_metrics['portfolio_value']:,.2f}")
print(f"   Leverage Ratio: {risk_metrics['leverage_ratio']:.2%}")
print(f"   Concentration Risk: {risk_metrics['concentration_risk']:.1f}%")
print(f"   Risk Score: {risk_metrics['risk_score']}/10")

# Check margin for planned trades
planned_orders = [
    {
        "exchange": "NFO",
        "tradingsymbol": "NIFTY25JAN25500CE",
        "quantity": "50",
        "price": "150.0",
        "product": "MIS",
        "transactiontype": "BUY"
    }
]

margin_check = risk_mgr.check_margin_requirements(planned_orders)
print(f"\nüí∞ Margin Check:")
print(f"   Can Execute: {'‚úÖ' if margin_check['can_execute'] else '‚ùå'}")
print(f"   Required Margin: ‚Çπ{margin_check.get('required_margin', 0):,.2f}")
print(f"   Available Cash: ‚Çπ{margin_check.get('available_cash', 0):,.2f}")
```

### 6. Real-time Portfolio Monitoring

```python
import time
import threading

class PortfolioMonitor:
    """Real-time portfolio monitoring"""
    
    def __init__(self, analyzer: PortfolioAnalyzer):
        self.analyzer = analyzer
        self.monitoring = False
        self.alerts = []
    
    def add_alert(self, alert_type: str, threshold: float):
        """Add portfolio alert"""
        self.alerts.append({
            'type': alert_type,
            'threshold': threshold,
            'triggered': False
        })
    
    def start_monitoring(self, interval: int = 30):
        """Start real-time monitoring"""
        self.monitoring = True
        
        def monitor_loop():
            while self.monitoring:
                try:
                    summary = self.analyzer.get_portfolio_summary()
                    self.check_alerts(summary)
                    
                    print(f"‚è∞ {datetime.now().strftime('%H:%M:%S')} - Portfolio Update:")
                    print(f"   Total P&L: ‚Çπ{summary['overall_pnl']['total_pnl']:,.2f}")
                    print(f"   Day P&L: ‚Çπ{summary['positions_summary']['day_pnl']:,.2f}")
                    print("-" * 40)
                    
                    time.sleep(interval)
                    
                except Exception as e:
                    print(f"Monitoring error: {e}")
                    time.sleep(interval)
        
        monitor_thread = threading.Thread(target=monitor_loop)
        monitor_thread.daemon = True
        monitor_thread.start()
    
    def check_alerts(self, summary: Dict):
        """Check portfolio alerts"""
        total_pnl = summary['overall_pnl']['total_pnl']
        day_pnl = summary['positions_summary']['day_pnl']
        
        for alert in self.alerts:
            if alert['triggered']:
                continue
                
            if alert['type'] == 'total_loss' and total_pnl < -alert['threshold']:
                print(f"üö® ALERT: Total loss exceeded ‚Çπ{alert['threshold']:,.2f}")
                alert['triggered'] = True
            elif alert['type'] == 'day_loss' and day_pnl < -alert['threshold']:
                print(f"üö® ALERT: Day loss exceeded ‚Çπ{alert['threshold']:,.2f}")
                alert['triggered'] = True
            elif alert['type'] == 'total_profit' and total_pnl > alert['threshold']:
                print(f"üéâ ALERT: Total profit exceeded ‚Çπ{alert['threshold']:,.2f}")
                alert['triggered'] = True
    
    def stop_monitoring(self):
        """Stop monitoring"""
        self.monitoring = False

# Usage
monitor = PortfolioMonitor(analyzer)

# Add alerts
monitor.add_alert('day_loss', 5000)  # Alert if day loss > ‚Çπ5,000
monitor.add_alert('total_profit', 10000)  # Alert if total profit > ‚Çπ10,000

# Start monitoring
monitor.start_monitoring(interval=30)  # Check every 30 seconds

# Stop after some time
time.sleep(300)  # Run for 5 minutes
monitor.stop_monitoring()
```

This comprehensive Portfolio & Margin documentation provides:

1. **Complete API implementations** for all portfolio and margin endpoints
2. **Advanced portfolio analysis** with detailed metrics and reporting
3. **Risk management tools** for position sizing and risk assessment
4. **Real-time monitoring** capabilities for live portfolio tracking
5. **Margin calculation utilities** for trade planning
6. **Position conversion tools** for portfolio management

The implementation is designed for complete local recreation and includes all necessary components for building a sophisticated portfolio management system.